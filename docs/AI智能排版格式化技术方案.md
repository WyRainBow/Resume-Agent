# AI 智能排版格式化技术方案

## 一、需求分析

### 1.1 核心需求

实现一个智能排版格式化功能，支持双向转换，能够自动识别内容格式并执行相应的转换操作。

### 1.2 使用场景

#### 场景1：紧凑格式 → 段落格式（主要需求）

**输入格式（需要转换的）：**
- 所有内容在一行或几行中，多个技能用空格分隔
- 格式为 `类别: 描述`，例如：`后端: 熟悉若干编程语言或服务框架 数据库: 了解常见数据库及调优思路 缓存: 掌握缓存策略与典型问题处理`

**期望输出格式：**
- 每个技能独立成行（段落格式）
- 每个技能之间用换行分隔
- 保持 `类别: 描述` 格式

#### 场景2：段落格式 → 列表格式（反向转换）

**输入格式（已排好段落的）：**
- 每个技能独立成行，格式为段落

**期望输出格式：**
- 可以转换为无序列表（`<ul><li>`）
- 或者转换为有序列表（`<ol><li>`）

#### 场景3：列表格式 → 段落格式

**输入格式：**
- 内容已经是列表格式（`<ul><li>` 或 `<ol><li>`）

**期望输出格式：**
- 转换为段落格式，每个列表项成为一个段落

### 1.3 功能要求

1. **智能识别**：自动检测当前内容格式（紧凑/段落/列表）
2. **双向转换**：支持格式之间的相互转换
3. **格式保持**：保留原有的 HTML 格式标签（如加粗、斜体等）
4. **智能分割**：正确识别 `类别: 描述` 的边界，避免错误分割
5. **可复用性**：组件可在多个模块中使用
6. **性能优化**：默认使用规则格式化（快速），可选 AI 增强（智能）

## 二、技术实现方案

### 2.1 架构设计

采用组件化设计，分为三个核心部分：

1. **格式化工具函数**（`formatLayoutUtils.ts`）
   - 负责格式检测和转换逻辑
   - 纯函数设计，无副作用
   - 支持 SSR 环境

2. **格式化对话框组件**（`FormatLayoutDialog.tsx`）
   - UI 交互层
   - 左右对比预览
   - 规则格式化 + 可选 AI 增强

3. **富文本编辑器集成**（`RichEditor/index.tsx`）
   - 在工具栏添加"AI 智能排版"按钮
   - 调用格式化对话框

### 2.2 格式检测算法

#### 2.2.1 格式类型定义

- **紧凑格式（compact）**：所有内容在一行或很少行中，包含多个技能项
- **段落格式（paragraph）**：每个技能独立成行，使用段落标签
- **列表格式（list）**：使用列表标签（`<ul>`、`<ol>`、`<li>`）
- **未知格式（unknown）**：无法识别的格式

#### 2.2.2 检测流程

1. 检查是否包含列表结构（`<ul>`、`<ol>`、`<li>`）
   - 如果包含 → 返回 `list`

2. 提取纯文本，按换行分割
   - 如果行数 > 1 且符合技能格式 → 返回 `paragraph`
   - 如果行数 ≤ 2 且包含多个技能 → 返回 `compact`

3. 检查是否符合技能格式（`类别: 描述`）
   - 如果符合 → 返回 `paragraph` 或 `compact`
   - 否则 → 返回 `unknown`

### 2.3 格式转换算法

#### 2.3.1 紧凑格式 → 段落格式

**核心挑战**：正确分割技能项，避免错误分割

**解决方案**：
1. 使用正则表达式匹配 `类别: 描述` 模式
2. 识别冒号后的空格作为分割点
3. 降级方案：查找所有 `类别: ` 的位置，按位置分割

**处理流程**：
1. 提取纯文本
2. 使用智能分割算法识别每个技能项
3. 将每个技能项转换为段落标签
4. 保留原有的 HTML 格式（如加粗等）

#### 2.3.2 段落格式 → 列表格式

**处理流程**：
1. 解析所有段落标签（`<p>`）
2. 提取每个段落的内容
3. 将每个段落转换为列表项（`<li>`）
4. 根据用户选择使用有序或无序列表
5. 保留原有的 HTML 格式

#### 2.3.3 列表格式 → 段落格式

**处理流程**：
1. 解析所有列表项（`<li>`）
2. 提取每个列表项的内容
3. 将每个列表项转换为段落标签（`<p>`）
4. 保留原有的 HTML 格式

### 2.4 AI 增强方案

#### 2.4.1 使用场景

- 规则格式化无法正确处理的复杂格式
- 用户需要更智能的格式识别和转换
- 处理特殊格式或边界情况

#### 2.4.2 实现方式

1. **API 调用**：复用现有的 `rewriteResumeStream` API
2. **Prompt 设计**：针对排版格式化的专用指令
3. **流式显示**：使用打字机效果实时显示 AI 生成内容
4. **降级处理**：AI 失败时回退到规则格式化

#### 2.4.3 Prompt 策略

- 明确说明转换目标（列表 ↔ 段落）
- 强调保留 HTML 格式标签
- 要求保持 `类别: 描述` 格式
- 指定输出格式要求

### 2.5 用户体验设计

#### 2.5.1 交互流程

1. 用户点击"AI 智能排版"按钮
2. 对话框打开，自动检测当前格式
3. 立即显示规则格式化结果（预览）
4. 用户可选择：
   - 直接应用规则格式化结果（快速）
   - 启用 AI 增强（等待 AI 处理）
   - 选择列表类型（有序/无序，仅在转换为列表时）

#### 2.5.2 UI 设计

- **左右对比布局**：原文 vs 格式化后
- **实时预览**：规则格式化立即显示
- **状态提示**：显示当前处理状态
- **选项控制**：AI 增强开关、列表类型选择

### 2.6 性能优化

#### 2.6.1 规则格式化（默认）

- **优势**：本地处理，无需网络请求
- **速度**：毫秒级响应
- **成本**：无 API 调用成本
- **适用**：大部分常见格式

#### 2.6.2 AI 增强（可选）

- **优势**：更智能，处理复杂格式
- **速度**：需要等待 AI 响应（通常 2-5 秒）
- **成本**：每次调用消耗 AI API 额度
- **适用**：复杂格式或规则无法处理的情况

### 2.7 错误处理

#### 2.7.1 规则格式化失败

- 捕获异常，返回原内容
- 记录错误日志
- 提示用户使用 AI 增强

#### 2.7.2 AI 格式化失败

- 显示错误提示
- 自动回退到规则格式化结果
- 允许用户重试

### 2.8 边界情况处理

#### 2.8.1 空内容

- 检测空内容，直接返回
- 不执行格式化操作

#### 2.8.2 混合格式

- 优先识别主要格式
- 尝试统一转换
- 无法处理时提示用户

#### 2.8.3 特殊字符

- 正确转义 HTML 特殊字符
- 保留用户输入的格式标签
- 处理中文字符和标点符号

## 三、实现细节

### 3.1 组件接口设计

**FormatLayoutDialog 组件 Props：**
- `open`: 对话框显示状态
- `onOpenChange`: 状态变更回调
- `content`: 输入的 HTML 内容
- `onApply`: 应用格式化结果的回调
- `resumeData`: 简历数据（用于 AI 增强）
- `path`: JSON 路径（用于 AI 增强）

### 3.2 工具函数设计

**核心函数：**
- `detectContentFormat()`: 检测内容格式类型
- `formatLayoutByRules()`: 规则格式化主函数
- `needsFormatting()`: 检测是否需要格式化
- `splitCompactSkills()`: 智能分割紧凑格式的技能项

### 3.3 状态管理

**组件内部状态：**
- `isFormatting`: 是否正在格式化
- `useAI`: 是否使用 AI 增强
- `formattedContent`: 格式化后的内容
- `currentFormat`: 当前内容格式
- `targetFormat`: 目标格式
- `useOrderedList`: 是否使用有序列表

## 四、技术优势

### 4.1 可复用性

- 独立组件设计，可在任何模块使用
- 通过 Props 传入内容和回调函数
- 不依赖特定业务逻辑

### 4.2 性能优化

- 默认使用规则格式化，快速响应
- AI 增强作为可选功能，按需使用
- 避免不必要的 API 调用

### 4.3 用户体验

- 左右对比预览，直观展示效果
- 实时格式化，无需等待
- 支持撤销和重做
- 清晰的选项控制

### 4.4 可维护性

- 模块化设计，职责清晰
- 纯函数设计，易于测试
- 完善的错误处理
- 详细的代码注释

## 五、未来扩展

### 5.1 功能扩展

- 支持更多格式类型（表格、引用等）
- 自定义格式化规则
- 批量格式化多个模块
- 格式化历史记录

### 5.2 性能优化

- 缓存格式化结果
- 增量格式化（只处理变更部分）
- Web Worker 处理大量内容

### 5.3 用户体验

- 格式化动画效果
- 更多预览选项
- 快捷键支持
- 格式化模板

## 六、总结

本方案实现了一个智能、高效、可复用的排版格式化功能，通过规则格式化 + AI 增强的双重策略，既保证了快速响应，又提供了智能处理能力。组件化设计使其可以在多个模块中复用，提升了代码的可维护性和用户体验。



# AI 智能排版功能使用说明

## 功能概述

AI 智能排版功能是一个双层处理系统：
1. **规则格式化**（快速）：本地处理，毫秒级响应
2. **AI 增强**（智能）：可选的 AI 优化，处理复杂格式

## 支持的格式转换

### 1. 紧凑格式 → 段落格式
- **输入**：所有内容在一行或几行中，多个技能用空格分隔
- **示例**：`后端: 熟悉若干编程语言 数据库: 了解常见数据库`
- **输出**：每个技能独立成段

### 2. 段落格式 → 列表格式
- **输入**：每个技能独立成行
- **输出**：转换为无序列表（`<ul>`）或有序列表（`<ol>`）

### 3. 列表格式 → 段落格式
- **输入**：使用列表标签的内容
- **输出**：转换为段落格式

## 使用方法

### 在富文本编辑器中使用

1. 在富文本编辑器中输入或粘贴内容
2. 点击工具栏中的 **"AI 智能排版"** 按钮
3. 系统会自动：
   - 检测当前内容格式
   - 立即显示规则格式化结果
   - 如有简历数据，自动进行 AI 增强优化

### 格式选项

- **列表类型**：当转换为列表时，可选择：
  - 无序列表（•）
  - 有序列表（1. 2. 3.）

### 快捷操作

- **立即显示**：点击 "立即显示" 按钮跳过打字机效果
- **重新格式化**：点击 "重新格式化" 按钮重新处理
- **应用格式化**：点击 "应用格式化" 按钮应用结果

## 技术特性

### 性能优化

- 规则格式化：本地处理，无需网络请求
- AI 增强：可选功能，仅处理复杂格式
- 超时处理：10秒超时保护
- 错误恢复：AI 失败时自动回退到规则格式化

### 智能识别

- 自动检测内容格式类型
- 智能分割紧凑格式文本
- 保留 HTML 格式标签（如 `<strong>`、`<em>` 等）

### 用户体验

- 左右对比预览
- 实时处理进度显示
- 流畅的打字机效果
- 清晰的状态提示

## 常见问题

### Q: 为什么点击按钮后没有反应？
A: 请确保：
1. 编辑器中有内容
2. 浏览器控制台没有错误信息
3. 后端服务正常运行

### Q: AI 增强很慢怎么办？
A: 可以：
1. 点击 "立即显示" 跳过打字效果
2. 直接使用规则格式化结果（已足够好）
3. 等待 AI 增强完成（通常 2-5 秒）

### Q: 格式识别不准确怎么办？
A: 系统会：
1. 优先识别主要格式
2. 尝试统一转换
3. AI 增强会进一步优化

### Q: 如何撤销格式化？
A: 使用编辑器的撤销功能（Ctrl+Z 或 Cmd+Z）

## 调试信息

打开浏览器控制台可以看到详细的处理日志：
- 检测到的内容格式
- 目标格式类型
- 规则格式化完成提示
- AI 增强开始/完成提示

## 更新日志

- 优化了打字机效果速度
- 添加了错误处理和超时保护
- 改进了格式检测算法
- 增强了用户界面反馈
- 