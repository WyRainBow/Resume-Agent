# 简历渲染优化方案

## 一、问题分析

### 1.1 当前架构的问题

```
用户输入 → handleEditorSave() → renderPDF() → 后端 LaTeX 编译 → 返回 PDF
```

**核心问题**：每次输入都触发完整的 PDF 渲染（后端 LaTeX 编译），这是一个**高成本操作**被误用为**编辑反馈**。

### 1.2 当前代码流程

```typescript
// WorkspacePage.tsx
const handleEditorSave = async (newResume: Resume, sectionOrder?: string[]) => {
  setResume(newResume)
  autoSave(newResume) // 1秒防抖保存到 localStorage
  
  // 问题：每次保存都触发 PDF 渲染
  if (previewMode === 'pdf') {
    const blob = await renderPDF(newResume, ...)  // 🔴 高成本操作
    setPdfBlob(blob)
  }
}
```

### 1.3 简历场景的特点

| 特点 | 说明 |
|------|------|
| 静态结构 | 模板结构固定，90% 只是文字变化 |
| 用户关注点 | 排版是否正确、是否溢出一页、段落感觉 |
| 渲染成本 | PDF 生成慢（LaTeX 编译），HTML 预览快 |

---

## 二、优化方案：三层渲染架构

### 2.1 核心思路

将渲染分为三个层级，根据触发条件使用不同成本的渲染方式：

| 渲染类型 | 触发条件 | 成本 | 用途 | 实现方式 |
|----------|----------|------|------|----------|
| **文本替换** | 每次输入 | 极低 | 编辑反馈 | 直接更新 DOM |
| **预览渲染** | 停止输入 500ms | 中 | 排版感知 | HTML/CSS 渲染 |
| **最终渲染** | 显式行为（导出/保存） | 高 | 导出 PDF | LaTeX 编译 |

### 2.2 架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户输入                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Layer 1: 文本替换（实时）                                        │
│  ─────────────────────────                                       │
│  • 直接更新对应 DOM 节点                                          │
│  • 不触发任何渲染                                                 │
│  • 成本：O(1)                                                    │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ debounce 500ms
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Layer 2: 预览渲染（延迟）                                        │
│  ─────────────────────────                                       │
│  • HTML/CSS 渲染                                                 │
│  • 更新 HtmlPreview 组件                                         │
│  • 不生成 PDF、不分页                                             │
│  • 成本：O(n) 轻量                                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ 显式触发（点击按钮）
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Layer 3: 最终渲染（显式）                                        │
│  ─────────────────────────                                       │
│  • 后端 LaTeX 编译                                               │
│  • 生成真正的 PDF                                                │
│  • 触发条件：导出、保存、切换模板                                  │
│  • 成本：O(n²) 高                                                │
└─────────────────────────────────────────────────────────────────┘
```

---

## 三、技术实现

### 3.1 新增状态管理

```typescript
// WorkspacePage.tsx 新增状态
const [previewResume, setPreviewResume] = useState<Resume | null>(null)  // 预览用的数据
const [pdfDirty, setPdfDirty] = useState(false)  // PDF 是否需要重新生成
const previewDebounceRef = useRef<ReturnType<typeof setTimeout> | null>(null)
```

### 3.2 Layer 1: 文本替换（实时）

**目标**：用户输入时，立即更新编辑器中的数据，但不触发任何渲染。

```typescript
// ResumeEditor 内部：实时更新数据
const handleFieldChange = (field: string, value: string) => {
  // 1. 立即更新本地状态（用于输入框显示）
  setLocalData(prev => ({ ...prev, [field]: value }))
  
  // 2. 通知父组件数据变化（不触发渲染）
  onDataChange?.(field, value)
}
```

### 3.3 Layer 2: 预览渲染（防抖 500ms）

**目标**：用户停止输入 500ms 后，更新 HTML 预览（轻量渲染）。

```typescript
// WorkspacePage.tsx
const handleEditorChange = useCallback((newResume: Resume) => {
  // 1. 立即更新编辑器数据
  setResume(newResume)
  
  // 2. 标记 PDF 需要重新生成
  setPdfDirty(true)
  
  // 3. 防抖更新预览（500ms）
  if (previewDebounceRef.current) {
    clearTimeout(previewDebounceRef.current)
  }
  previewDebounceRef.current = setTimeout(() => {
    setPreviewResume(newResume)  // 触发 HTML 预览更新
    autoSave(newResume)          // 保存到 localStorage
  }, 500)
}, [autoSave])
```

### 3.4 Layer 3: 最终渲染（显式触发）

**目标**：只在用户明确需要时才生成 PDF。

```typescript
// 触发条件
const PDF_RENDER_TRIGGERS = [
  '下载 PDF',
  '保存并更新',  // 明确的保存按钮
  '切换模板',
  '切换字体',
  'AI 排版优化'
]

// 生成 PDF 函数
const generatePDF = useCallback(async () => {
  if (!resume || !pdfDirty) return  // 无变化则跳过
  
  setLoadingPdf(true)
  try {
    const blob = await renderPDF(resume, false, currentSectionOrder)
    setPdfBlob(blob)
    setPdfDirty(false)  // 重置脏标记
  } catch (error) {
    console.error('PDF 渲染失败:', error)
  } finally {
    setLoadingPdf(false)
  }
}, [resume, pdfDirty, currentSectionOrder])

// 下载时自动生成最新 PDF
const handleDownload = async () => {
  if (pdfDirty) {
    await generatePDF()
  }
  // 下载逻辑...
}
```

### 3.5 预览模式切换

```typescript
// 默认使用 HTML 预览（轻量）
const [previewMode, setPreviewMode] = useState<'html' | 'pdf'>('html')

// 预览区域
{previewMode === 'html' ? (
  <HtmlPreview 
    resume={previewResume || resume} 
    sectionOrder={currentSectionOrder}
  />
) : (
  <PDFViewer 
    pdfBlob={pdfBlob}
    // PDF 编辑功能保留
    onContentChange={handlePDFContentChange}
  />
)}
```

---

## 四、UI/UX 调整

### 4.1 按钮调整

| 原按钮 | 新按钮 | 行为变化 |
|--------|--------|----------|
| 保存并更新 | 保存并更新 | 触发 Layer 3（PDF 渲染） |
| 下载 PDF | 下载 PDF | 先检查 `pdfDirty`，必要时触发渲染 |
| - | 预览 PDF | 新增：切换到 PDF 预览模式并渲染 |

### 4.2 状态提示

```typescript
// 显示 PDF 是否需要更新
{pdfDirty && (
  <span style={{ color: '#f59e0b', fontSize: '12px' }}>
    ● 有未同步的修改
  </span>
)}
```

### 4.3 自动保存策略

```typescript
// 自动保存到 localStorage（不触发 PDF 渲染）
const autoSave = useCallback((resumeData: Resume) => {
  if (currentResumeId) {
    saveResume(resumeData, currentResumeId)
  }
}, [currentResumeId])

// 在 Layer 2（预览渲染）时执行自动保存
```

---

## 五、实现步骤

### Phase 1: 基础架构（预计 2 小时）

1. [ ] 新增状态：`previewResume`、`pdfDirty`
2. [ ] 修改 `handleEditorSave` → `handleEditorChange`（只更新数据，不渲染 PDF）
3. [ ] 添加防抖逻辑（500ms）
4. [ ] 提取 `generatePDF` 函数

### Phase 2: 预览切换（预计 1 小时）

1. [ ] 默认切换到 HTML 预览模式
2. [ ] 添加「预览 PDF」按钮
3. [ ] 下载时自动检查并生成 PDF

### Phase 3: UI 优化（预计 1 小时）

1. [ ] 添加「有未同步修改」提示
2. [ ] 优化按钮文案和行为
3. [ ] 测试各种边界情况

---

## 六、性能对比

### 优化前

```
输入 1 个字 → 等待 3-5s（PDF 渲染）
输入 10 个字 → 等待 30-50s（连续渲染）
```

### 优化后

```
输入 1 个字 → 0ms（无渲染）
输入 10 个字 → 0ms（无渲染）
停止输入 500ms → 50ms（HTML 预览）
点击「下载 PDF」→ 3-5s（一次性渲染）
```

**预期提升**：编辑体验从「卡顿」变为「丝滑」，PDF 渲染次数减少 90%+。

---

## 七、风险与回退

### 7.1 风险点

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| HTML 预览与 PDF 不一致 | 用户困惑 | 明确提示「预览仅供参考」|
| 用户忘记生成 PDF | 下载旧版本 | 下载前自动检查并生成 |
| 复杂排版问题 | HTML 无法展示 | 保留「预览 PDF」按钮 |

### 7.2 回退方案

如果用户反馈 HTML 预览效果差，可以：
1. 调整 HTML 预览样式，使其更接近 PDF
2. 提供「自动同步 PDF」选项（每 N 秒自动渲染一次）
3. 完全回退到原方案

---

## 八、总结

> **核心改变**：把「最终渲染」从「编辑反馈」中剥离出来，让每一层做它该做的事。

- **输入时**：只做文本替换，极致响应
- **停止后**：轻量预览，感知排版
- **导出时**：完整渲染，精确输出

这不是「优化渲染性能」，而是「用对渲染策略」。
